
def format_string(string):
    formatted = ""

    for line in string.split("\n"):
        if line.startswith("# "):
            formatted += f"## {line[2:]}\n"
        elif line.startswith("## "):
            formatted += f"### {line[3:]}\n"
        elif line.startswith("### "):
            formatted += f"#### {line[4:]}\n"
        else:
            formatted += f"{line}\n"

    with open("readable.md", "w", encoding="utf-8") as f:
        f.write(formatted)

    print("Formatted string written to readable.md")
    return formatted


def extract_evaluations(text):
    """
    Extracts evaluation sections from text that start with 'EVALUATION:' 
    and continue until an empty line is encountered.
    """
    evaluations = []
    lines = text.split('\n')

    i = 0
    while i < len(lines):
        line = lines[i].strip()
        
        # Check if line starts with "EVALUATION:"
        if line.startswith("EVALUATION:"):
            evaluation_lines = [line]
            i += 1
            
            # Continue collecting lines until empty line or end of text
            while i < len(lines):
                current_line = lines[i]
                
                # Stop if we hit an empty line
                if current_line.strip() == "":
                    break
                    
                evaluation_lines.append(current_line)
                i += 1
            
            # Join the evaluation lines and add to results
            evaluations.append('\n'.join(evaluation_lines))
        
        i += 1

    with open("evaluations.md", "w", encoding="utf-8") as f:
        for evaluation in evaluations:
            f.write(f"{evaluation}\n\n")

    print("Evaluations extracted and written to evaluations.md")

    return evaluations


# string = str(input("Enter the string to format:\n"))
string = """

{
    "get_context_(0)": {
        "step_name": "get_context_(0)",
        "prompt": "\n        <context>\n        <input> \n        # file: JSON Example file\n            description:\n                The JSON Example file is a sample data file that contains all unique entity types of the JSON Entities file, a response of a GET request to the API of an IoT platform.\n                It represents the data structure of the JSON Entities file, but with only one instance of each entity type.\n            content:\n                <data>[\n  {\n    \"id\": \"Hotel:example_hotel\",\n    \"type\": \"Hotel\",\n    \"name\": {\n      \"type\": \"Text\",\n      \"value\": \"example_hotel\",\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"AmbientTemperatureSensor\",\n    \"type\": \"AmbientTemperatureSensor\", \n    \"temperatureAmb\": {\n      \"type\": \"Number\",\n      \"value\": 0.0,\n      \"metadata\": {}\n    },\n    \"hasLocation\": {\n      \"type\": \"Relationship\",\n      \"value\": \"Hotel:example_hotel\",\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"HotelRoom:example_room\",\n    \"type\": \"HotelRoom\",\n    \"hasLocation\": {\n      \"type\": \"Text\",\n      \"value\": \"Hotel:fiware\",\n      \"metadata\": {}\n    },\n    \"name\": {\n      \"type\": \"Text\",\n      \"value\": \"example_room\",\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"TemperatureSensor:example_room\",\n    \"type\": \"TemperatureSensor\",\n    \"hasLocation\": {\n      \"type\": \"Relationship\",\n      \"value\": \"HotelRoom:example_room\",\n      \"metadata\": {}\n    },\n    \"temperature\": {\n      \"type\": \"Number\",\n      \"value\": 0.0,\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"CO2Sensor:example_room\",\n    \"type\": \"CO2Sensor\",\n    \"co2\": {\n      \"type\": \"Number\",\n      \"value\": 0.0,\n      \"metadata\": {}\n    },\n    \"hasLocation\": {\n      \"type\": \"Relationship\",\n      \"value\": \"HotelRoom:example_room\",\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"PresenceSensor:example_room\",\n    \"type\": \"PresenceSensor\",\n    \"hasLocation\": {\n      \"type\": \"Relationship\",\n      \"value\": \"HotelRoom:example_room\",\n      \"metadata\": {}\n    },\n    \"pir\": {\n      \"type\": \"Number\",\n      \"value\": 0.0,\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"FreshAirVentilation:example_room\",\n    \"type\": \"FreshAirVentilation\",\n    \"airFlowSetpoint\": {\n      \"type\": \"Number\",\n      \"value\": 0.0,\n      \"metadata\": {}\n    },\n    \"hasLocation\": {\n      \"type\": \"Relationship\",\n      \"value\": \"HotelRoom:example_room\",\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"RadiatorThermostat:example_room\",\n    \"type\": \"RadiatorThermostat\",\n    \"hasLocation\": {\n      \"type\": \"Relationship\",\n      \"value\": \"HotelRoom:example_room\",\n      \"metadata\": {}\n    },\n    \"temperatureSetpoint\": {\n      \"type\": \"Number\",\n      \"value\": 0.0,\n      \"metadata\": {}\n    }\n  },\n  {\n    \"id\": \"CoolingCoil:example_room\",\n    \"type\": \"CoolingCoil\",\n    \"fanSpeed\": {\n      \"type\": \"Number\",\n      \"value\": 0.0,\n      \"metadata\": {}\n    },\n    \"hasLocation\": {\n      \"type\": \"Relationship\",\n      \"value\": \"HotelRoom:example_room\",\n      \"metadata\": {}\n    }\n  }\n]</data>\n        </input>\n        API Specification path: 'LLM_models/API_specs\\FIWAR_ngsiV2_API_spec.json'\n        Ontology path: 'LLM_models/ontologies\\Brick.ttl'\n        Term Mapping Instructions: \n        \n        <term_mapping_instructions>\n        <instructions>\n        Based on the extraction of available Ontology Classes and Properties and\n        the list of terms that need to be mapped to the ontology,\n        for each term, you need to select the most appropriate ontology class or property for the domain entity or relation.\n        The goal is to inherit the attributes and relations from the selected Ontology Class or Property.\n\n        MAPPING CRITERIA: (in order of priority)\n        1. Exact semantic match\n        2. Functional equivalence (same purpose/behavior)\n        3. Hierarchical relationship (parent/child concepts)\n        4. Attribute similarity (same properties/characteristics)\n\n        SPECIAL CONSIDERATIONS:\n        - Distinguish locations, air systems, devices, actuation points, sensors\n        - Avoid category errors: don't confuse the thing itself with infrastructure that supports the thing\n\n        JUST FOR CLASSES:\n        - Respect system hierarchies (building → floor → room → equipment)\n        - When the Domain Entity seems to be a relation, select a class that would have this relation as a property.\n\n        JUST FOR PROPERTIES:\n        - Maintain the direction of the relationship original (subject → predicate → object), e. g.: is_instance_of NOT EQUAL TO is_instanciated_by\n        </instructions>\n        </term_mapping_instructions>\n        \n        </context>\n\n        <steps>\n        1. Find the suitable API endpoint for accessing numerical values of entities\n\n        1. Map JSON Entities to ontology Classes.\n\n        2. Decide which relations in the JSON file are 'numeric properties' and 'relational properties'.\n            numeric properties are properties that have a numerical value, like temperature, humidity, etc.\n            relational properties are properties that have a relation to another entity, like 'is located in', 'has sensor', etc.\n        \n        2.1 Map the relational properties to ontology properties.\n            Do not map the numerical properties to ontology properties.\n\n        2.2 Check if the selected ontology classes for the entities of the numerical properties have an (inherited) numerical property.\n        \n        2.3 If there are extra nodes to be added, add a new JSON entity to an imagenary list of extra nodes.\n            The extra nodes should have the name of the property they come from\n            Map this newly created entity to an ontology class by using the query '{property_name}'.\n\n        3. Now check again, if the newly created entities have an (inherited) numerical property and do steps 2.2 and 2.3 again before continuing.\n        </steps>\n\n        <output>\n        Return a JSON, containg:\n        - the API endpoint for data access\n        - enumeration of the numerical properties and relational properties\n        - the mapping of the JSON Entities to ontology classes and properties\n        - the name of the properties, that will be added to the JSON Entities as Extra Nodes and the names of the Extra Nodes and their mapped ontology classes.\n        </output>\n        \n        \n        <context>\n        # CoT Extraction\n        Bloom's Taxonomy:\n        - Remembering: {information} (Recall information)\n        - Understanding: {meaning} (Constructing meaning from information, e. g.: interpreting, exemplifying, classifying, summarizing, inferring, comparing, or explaining)\n        - Applying: {procedure} (using a procedure through executing, or implementing.)\n        - Analyzing: {analysis} (determine how concept parts relate to each other or how they interrelate, differentiating, organizing, and attributing, as well as being able to distinguish  between the components or parts.)\n        - Evaluating: {number of options considered} (Making judgments based on criteria and standards through checking and critiquing.)\n        - Creating: {newly created idea or element} (generating new ideas or elements.)\n\n        Knowledge Dimensions:\n        - Factual Knowledge: facts, terminology, or syntax needed to understand the domain.\n        - Conceptual Knowledge: classifications, principles, generalizations, theories, models, or structures pertinent to a particular disciplinary area\n        - Procedural Knowledge: How to do something, methods of inquiry, specific or finite skills, algorithms, techniques, and particular methodologies\n        - Metacognitive Knowledge: awareness of own cognition, strategic or reflective knowledge considering contextual and conditional knowledge and knowledge of self.\n        </context>\n\n        <instructions>\n        Do the task step by step.\n        Each step must:\n        - Perform exactly one logical action\n        - Have exactly one conceptual target\n        - be not devidable into smaller steps \n        - Produce exactly one concrete output\n        - Be completable in isolation\n        - Not require planning future steps\n\n        Output the thinking process as detailed as possible.\n        It is really important to output every little step of your reasoning, even if it seems obvious.\n\n        Process exactly ONE step at a time. \n        You cannot reference or work on any other step until the current one is complete. \n        After completing one step, explicitly state \"STEP COMPLETE\" before starting the next.\n        \n        You can only use information from:\n        - The original input\n        - Results from previously completed steps\n        - The current step you're working on\n        You cannot reference or anticipate future steps.\n        \n        For each step:\n        1. State what you're about to do\n            - context: the explicit context information that is needed to complete the step\n            - reason: the reasoning process that led to the step\n        2. Do it immediately \n        3. Show the result\n            - result: The actual concrete output produced (code, data, text) - not a description of what you will produce\n        4. Evaluate the step\n            - bloom: {objective} the Bloom's Taxonomy level and it's objective (max 7 words)\n            - dim: the Knowledge Dimension\n            - quantity: the number of context information items processed in this step. Items are either: entities, properties, relationships, paths, or lines of code.\n            - human_effort: own evaluation of the human effort required to complete this step (from 1 to 10, where 1 is very easy and 10 is very hard)\n        5. Move to next step\n\n        If you find yourself working on multiple entities simultaneously, STOP immediately and restart with only the first incomplete entity.\n        FINAL OUTPUT RULE: Only after ALL entities show 'ENTITY COMPLETE', combine all step results into the final deliverable.\n\n        Example format:\n        ...\n        STEP 1: {step name}\n            context: {context}\n            reason: {reasoning of the step}\n        EXECUTING: [actual code/work here]\n        RESULT:\n            result: {result of the step}\n        EVALUATION:\n            bloom: {bloom} {objective}\n            dim: {dim}\n            quantity: {quantity}\n            human_effort: {human_effort}\n\n        NEXT: STEP 2: {step name}\n        STEP COMPLETE\n        ...\n        </instructions>\n\n        <output>\n        Output the steps in <steps> tags. Put the response in output tags first, then the steps in <steps> tags after.\n        </output>\n        ",
        "thinking": "Okay, I'm given a task to map JSON entities to ontology classes and properties, and to identify numeric and relational properties in the JSON file. Let me approach this step by step as instructed.\n\nSTEP 1: Find the suitable API endpoint for accessing numerical values of entities\nFirst, I need to find the API endpoint for accessing numerical values of entities. I'll use the `get_endpoint_from_api_spec` function to find the best matching endpoint from the API specification for accessing the data.\n\nFor this, I need:\n- API specification path: 'LLM_models/API_specs\\FIWAR_ngsiV2_API_spec.json'\n- A query to the endpoint: Since we're looking for numerical values of entities, I'll use a query like \"retrieve entity attribute values\"\n\nI'll call the `get_endpoint_from_api_spec` function with these parameters.\n\nSTEP 2: Map JSON Entities to ontology Classes\nI need to map the JSON entities to ontology classes. From the JSON Example file, I can identify the following entity types:\n- Hotel\n- AmbientTemperatureSensor\n- HotelRoom\n- TemperatureSensor\n- CO2Sensor\n- PresenceSensor\n- FreshAirVentilation\n- RadiatorThermostat\n- CoolingCoil\n\nI'll use the `term_mapper` function to find the available ontology classes for these terms in the given ontology path 'LLM_models/ontologies\\Brick.ttl'.\n\nSTEP 3: Identify numeric properties and relational properties\nFrom the JSON Example file, I can identify the following properties:\n- name (for Hotel, HotelRoom)\n- temperatureAmb (for AmbientTemperatureSensor)\n- temperature (for TemperatureSensor)\n- co2 (for CO2Sensor)\n- pir (for PresenceSensor)\n- airFlowSetpoint (for FreshAirVentilation)\n- temperatureSetpoint (for RadiatorThermostat)\n- fanSpeed (for CoolingCoil)\n- hasLocation (for all entities except Hotel)\n\nNow, I need to categorize these properties into numeric properties and relational properties.\n\nNumeric properties (with type \"Number\"):\n- temperatureAmb\n- temperature\n- co2\n- pir\n- airFlowSetpoint\n- temperatureSetpoint\n- fanSpeed\n\nRelational properties (with type \"Relationship\" or \"Text\" but referring to another entity):\n- hasLocation\n\nSTEP 4: Map relational properties to ontology properties\nI'll use the `term_mapper` function to find the available ontology properties for the relational properties in the given ontology path 'LLM_models/ontologies\\Brick.ttl'.\n\nSTEP 5: Check if selected ontology classes have inherited numerical properties\nI'll use the `get_non_numeric_classes` function to check if the selected ontology classes for the entities with numerical properties have an (inherited) numerical property.\n\nSTEP 6: Add extra nodes if needed\nIf there are classes without an inherited numerical property, I'll need to create extra nodes based on the property names.\n\nNow, let's execute these steps one by one.\n\nLet's start with STEP 1: Find the suitable API endpoint for accessing numerical values of entities.",
        "response": "Based on the information provided, I'll work on mapping JSON entities to ontology classes and properties, identifying numerical and relational properties, and finding the appropriate API endpoint for data access.\n\nFirst, I need to find the suitable API endpoint for accessing entity data.",
        "performance": {
            "time": {
                "latency": 16.87,
                "tpot": 0.018,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 2918,
                "cache_creation_input_tokens": 1029,
                "cache_read_input_tokens": 0,
                "output_tokens": 937,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "get_endpoint_(0)": {
        "step_name": "get_endpoint_(0)",
        "prompt": "You are an expert API assistant.\nGiven the following user query and a list of API endpoints, select the single most relevant endpoint.\n\nUser query: retrieve entity attribute values\n\nAPI endpoints:\n1. GET /v2 Retrieve API Resources\n2. GET /v2/entities List Entities\n3. POST /v2/entities Create Entity\n4. GET /v2/entities/{entityId} Retrieve Entity\n5. DELETE /v2/entities/{entityId} Remove Entity\n6. GET /v2/entities/{entityId}/attrs Retrieve Entity Attributes\n7. PUT /v2/entities/{entityId}/attrs Replace all entity attributes\n8. POST /v2/entities/{entityId}/attrs Update or Append Entity Attributes\n9. PATCH /v2/entities/{entityId}/attrs Update Existing Entity Attributes\n10. GET /v2/entities/{entityId}/attrs/{attrName} Get attribute data\n11. PUT /v2/entities/{entityId}/attrs/{attrName} Update Attribute Data\n12. DELETE /v2/entities/{entityId}/attrs/{attrName} Remove a Single Attribute\n13. GET /v2/entities/{entityId}/attrs/{attrName}/value Get Attribute Value\n14. PUT /v2/entities/{entityId}/attrs/{attrName}/value Update Attribute Value\n15. GET /v2/types/ List Entity Types\n16. GET /v2/types/{entityType} Retrieve entity type\n17. GET /v2/subscriptions List Subscriptions\n18. POST /v2/subscriptions Create Subscription\n19. GET /v2/subscriptions/{subscriptionId} Retrieve Subscription\n20. DELETE /v2/subscriptions/{subscriptionId} Delete subscription\n21. PATCH /v2/subscriptions/{subscriptionId} Update Subscription\n22. GET /v2/registrations List Registrations\n23. POST /v2/registrations Create Registration\n24. GET /v2/registrations/{registrationId} Retrieve Registration\n25. DELETE /v2/registrations/{registrationId} Delete Registration\n26. PATCH /v2/registrations/{registrationId} Update Registration\n27. POST /v2/op/update Update\n28. POST /v2/op/query Query\n29. POST /v2/op/notify Notify\n\nReply ONLY with the number of the best matching endpoint. If none are relevant, reply with 0.\n        <context>\n        # CoT Extraction\n        Bloom's Taxonomy:\n        - Remembering: {information} (Recall information)\n        - Understanding: {meaning} (Constructing meaning from information, e. g.: interpreting, exemplifying, classifying, summarizing, inferring, comparing, or explaining)\n        - Applying: {procedure} (using a procedure through executing, or implementing.)\n        - Analyzing: {analysis} (determine how concept parts relate to each other or how they interrelate, differentiating, organizing, and attributing, as well as being able to distinguish  between the components or parts.)\n        - Evaluating: {number of options considered} (Making judgments based on criteria and standards through checking and critiquing.)\n        - Creating: {newly created idea or element} (generating new ideas or elements.)\n\n        Knowledge Dimensions:\n        - Factual Knowledge: facts, terminology, or syntax needed to understand the domain.\n        - Conceptual Knowledge: classifications, principles, generalizations, theories, models, or structures pertinent to a particular disciplinary area\n        - Procedural Knowledge: How to do something, methods of inquiry, specific or finite skills, algorithms, techniques, and particular methodologies\n        - Metacognitive Knowledge: awareness of own cognition, strategic or reflective knowledge considering contextual and conditional knowledge and knowledge of self.\n        </context>\n\n        <instructions>\n        Do the task step by step.\n        Each step must:\n        - Perform exactly one logical action\n        - Have exactly one conceptual target\n        - be not devidable into smaller steps \n        - Produce exactly one concrete output\n        - Be completable in isolation\n        - Not require planning future steps\n\n        Output the thinking process as detailed as possible.\n        It is really important to output every little step of your reasoning, even if it seems obvious.\n\n        Process exactly ONE step at a time. \n        You cannot reference or work on any other step until the current one is complete. \n        After completing one step, explicitly state \"STEP COMPLETE\" before starting the next.\n        \n        You can only use information from:\n        - The original input\n        - Results from previously completed steps\n        - The current step you're working on\n        You cannot reference or anticipate future steps.\n        \n        For each step:\n        1. State what you're about to do\n            - context: the explicit context information that is needed to complete the step\n            - reason: the reasoning process that led to the step\n        2. Do it immediately \n        3. Show the result\n            - result: The actual concrete output produced (code, data, text) - not a description of what you will produce\n        4. Evaluate the step\n            - bloom: {objective} the Bloom's Taxonomy level and it's objective (max 7 words)\n            - dim: the Knowledge Dimension\n            - quantity: the number of context information items processed in this step. Items are either: entities, properties, relationships, paths, or lines of code.\n            - human_effort: own evaluation of the human effort required to complete this step (from 1 to 10, where 1 is very easy and 10 is very hard)\n        5. Move to next step\n\n        If you find yourself working on multiple entities simultaneously, STOP immediately and restart with only the first incomplete entity.\n        FINAL OUTPUT RULE: Only after ALL entities show 'ENTITY COMPLETE', combine all step results into the final deliverable.\n\n        Example format:\n        ...\n        STEP 1: {step name}\n            context: {context}\n            reason: {reasoning of the step}\n        EXECUTING: [actual code/work here]\n        RESULT:\n            result: {result of the step}\n        EVALUATION:\n            bloom: {bloom} {objective}\n            dim: {dim}\n            quantity: {quantity}\n            human_effort: {human_effort}\n\n        NEXT: STEP 2: {step name}\n        STEP COMPLETE\n        ...\n        </instructions>\n\n        <output>\n        Output the steps in <steps> tags. Put the response in output tags first, then the steps in <steps> tags after.\n        </output>\n        ",
        "thinking": "I need to determine which API endpoint is most relevant to the user query \"retrieve entity attribute values\". Let me approach this step by step.\n\nSTEP 1: Understand the user query\n    context: The user query is \"retrieve entity attribute values\"\n    reason: I need to understand what the user wants to do\n\nTo understand the user query, I need to break down the key terms:\n- \"retrieve\" - indicates a GET operation\n- \"entity\" - refers to an entity in the API\n- \"attribute values\" - refers to the values of attributes for an entity\n\nThe user wants to get (retrieve) the values of attributes belonging to an entity.\n\nEVALUATION:\n    bloom: Understanding query intent\n    dim: Conceptual Knowledge\n    quantity: 3 (retrieve, entity, attribute values)\n    human_effort: 2\n\nSTEP COMPLETE\n\nSTEP 2: Review available API endpoints\n    context: The list of 29 API endpoints provided\n    reason: I need to review all the endpoints to find the most relevant one\n\nLooking at the list of endpoints, I need to identify those that involve retrieving attribute values from entities:\n\nSeveral endpoints involve entities and attributes:\n- #6: GET /v2/entities/{entityId}/attrs (Retrieve Entity Attributes)\n- #10: GET /v2/entities/{entityId}/attrs/{attrName} (Get attribute data)\n- #13: GET /v2/entities/{entityId}/attrs/{attrName}/value (Get Attribute Value)\n\nThese are the most relevant ones to \"retrieving entity attribute values\".\n\nEVALUATION:\n    bloom: Analyzing API endpoints\n    dim: Factual Knowledge\n    quantity: 29 (all endpoints)\n    human_effort: 4\n\nSTEP COMPLETE\n\nSTEP 3: Assess the most relevant endpoint\n    context: The three endpoints identified in Step 2\n    reason: I need to determine which one most precisely matches the user's intent\n\nLet's analyze each of the three endpoints in detail:\n\n1. GET /v2/entities/{entityId}/attrs (Retrieve Entity Attributes)\n   This endpoint retrieves all attributes for a specific entity, including their data and metadata.\n\n2. GET /v2/entities/{entityId}/attrs/{attrName} (Get attribute data)\n   This endpoint retrieves data for a specific attribute of a specific entity, including metadata.\n\n3. GET /v2/entities/{entityId}/attrs/{attrName}/value (Get Attribute Value)\n   This endpoint specifically retrieves just the value of a specific attribute for a specific entity.\n\nSince the user query is specifically about \"attribute values\", endpoint #13 is the most precise match, as it specifically focuses on retrieving the value of an attribute rather than the entire attribute data or all attributes.\n\nEVALUATION:\n    bloom: Evaluating endpoint relevance\n    dim: Conceptual Knowledge\n    quantity: 3 (three endpoints)\n    human_effort: 5\n\nSTEP COMPLETE\n\nSTEP 4: Make final selection\n    context: The analysis from Step 3\n    reason: I need to provide a single definitive answer\n\nBased on the detailed analysis, endpoint #13 (GET /v2/entities/{entityId}/attrs/{attrName}/value - Get Attribute Value) is the most relevant to the user query \"retrieve entity attribute values\".\n\nThis endpoint specifically focuses on retrieving attribute values, which is exactly what the user is asking for.\n\nTherefore, the answer is 13.\n\nEVALUATION:\n    bloom: Applying selection criteria\n    dim: Procedural Knowledge\n    quantity: 1 (final endpoint)\n    human_effort: 2\n\nSTEP COMPLETE",
        "response": "Based on the user query \"retrieve entity attribute values\", the most relevant endpoint is:\n\n13\n\n",
        "performance": {
            "time": {
                "latency": 13.82,
                "tpot": 0.0162,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 1999,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 0,
                "output_tokens": 851,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "get_endpoint_from_api_spec": {
        "tool_name": "get_endpoint_from_api_spec",
        "tool_input": {
            "api_spec_path": "LLM_models/API_specs\\FIWAR_ngsiV2_API_spec.json",
            "query": "retrieve entity attribute values"
        },
        "tool_result": {
            "endpoint": "https://fiware.eonerc.rwth-aachen.de/v2/entities/{entityId}/attrs/{attrName}/value"
        }
    },
    "get_context_(1)": {
        "step_name": "get_context_(1)",
        "prompt": "",
        "thinking": "No Thinking",
        "response": "Now I need to map the JSON entities to ontology classes. Let me identify the entities from the JSON example first:",
        "performance": {
            "time": {
                "latency": 3.29,
                "tpot": 0.0162,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 3904,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 1029,
                "output_tokens": 203,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "term_mapper": {
        "tool_name": "term_mapper",
        "tool_input": {
            "ontology_path": "LLM_models/ontologies\\Brick.ttl",
            "terms": {
                "Hotel": "class",
                "AmbientTemperatureSensor": "class",
                "HotelRoom": "class",
                "TemperatureSensor": "class",
                "CO2Sensor": "class",
                "PresenceSensor": "class",
                "FreshAirVentilation": "class",
                "RadiatorThermostat": "class",
                "CoolingCoil": "class"
            }
        },
        "tool_result": {
            "mapped_terms": "Classes:\n- sosa:FeatureOfInterest\n- brick:Class\n  - brick:Location\n    - brick:Floor\n      - brick:Rooftop\n    - brick:Space\n      - brick:Media_Hot_Desk: A non-enclosed space used by members of the media temporarily to cover an event while they are present at a venue\n      - brick:Common_Space\n        - brick:Lounge: A room for lesiure activities or relaxing\n        - brick:Cafeteria: A space to serve food and beverages\n        - brick:Lobby: A space just after the entrance to a building or other space of a building, where visitors can wait\n      - brick:Room\n        - brick:Medical_Room: A class of rooms used for medical purposes\n        - brick:Storage_Room: A class of spaces used for storage\n        - brick:Janitor_Room: A room set aside for the storage of cleaning equipment and supplies\n        - brick:Server_Room\n        - brick:Office: A class of rooms dedicated for work or study\n        - brick:Rest_Room: A room that provides toilets and washbowls. Alternate spelling of Restroom\n        - brick:Reception: A space, usually in a lobby, where visitors to a building or space can go to after arriving at a building and inform building staff that they have arrived\n        - brick:Telecom_Room: A class of spaces used to support telecommuncations and IT equipment\n        - brick:Security_Service_Room: A class of spaces used by the security staff of a facility\n          - brick:Detention_Room: A space for the temporary involuntary confinement of people\n        - brick:Laboratory\n          - brick:Hot_Box: hot air chamber forming part of an air handler.\n        - brick:Service_Room\n          - brick:Electrical_Room: A class of service rooms that house electrical equipment for a building\n  - brick:Collection\n    - brick:Loop\n      - brick:Water_Loop\n        - brick:Chilled_Water_Loop: A collection of equipment that transport and regulate chilled water among each other\n    - brick:System\n      - brick:Gas_System\n      - brick:Safety_System\n      - brick:Heating_Ventilation_Air_Conditioning_System\n        - brick:Refrigeration_System: System designed to remove heat from a space or substance, typically using a refrigerant in a closed loop\n        - brick:VRF_System\n        - brick:Air_System\n          - brick:Ventilation_Air_System: The equipment, devices, and conduits that handle the introduction and distribution of ventilation air in the building\n        - brick:Water_System\n          - brick:Chilled_Water_System: The equipment, devices and conduits that handle the production and distribution of chilled water in a building\n          - brick:Hot_Water_System\n            - brick:Radiation_Hot_Water_System\n  - brick:Equipment\n    - brick:Fire_Safety_Equipment\n      - brick:Heat_Detector\n      - brick:Smoke_Detector\n      - brick:Fire_Alarm\n    - brick:HVAC_Equipment\n      - brick:Cooling_Tower: A cooling tower is a heat rejection device that rejects waste heat to the atmosphere through the cooling of a water stream to a lower temperature. Cooling towers may either use the evaporation of water to remove process heat and cool the working fluid to near the wet-bulb air temperature or, in the case of closed circuit dry cooling towers, rely solely on air to cool the working fluid to near the dry-bulb air temperature.\n      - brick:Cooling_Valve: A valve that controls air temperature by modulating the amount of cold water flowing through a cooling coil\n      - brick:Cold_Deck: Part of a dual duct air handling unit that supplies cooling to a building\n      - brick:Dry_Cooler: A dry cooler is a fluid cooler that uses air, a relatively dry, non-liquid fluid to accomplish process cooling. (https://submer.com/submer-academy/library/dry-cooler/)\n      - brick:Chiller: Refrigerating machine used to transfer heat between fluids. Chillers are either direct expansion with a compressor or absorption type.\n        - brick:Water_Cooled_Chiller: A chiller system using water in the heat exchange process, employed in industrial or commercial facilities for cooling\n        - brick:Air_Cooled_Chiller: A chiller that uses air to cool the refrigerant, used in various commercial and industrial cooling applications\n      - brick:Economizer: Device that, on proper variable sensing, initiates control signals or actions to conserve energy. A control system that reduces the mechanical heating and cooling requirement.\n      - brick:Air_Handling_Unit\n        - brick:DOAS: See Dedicated_Outdoor_Air_System_Unit\n        - brick:Pre-Cooling_Air_Unit: A type of AHU, use to pre-treat the outdoor air before feed to AHU\n        - brick:PAU: A type of AHU, use to pre-treat the outdoor air before feed to AHU\n        - brick:Makeup_Air_Unit: A device designed to condition ventilation air introduced into a space or to replace air exhausted from a process or general area exhaust. The device may be used to prevent negative pressure within buildings or to reduce airborne contaminants in a space.\n        - brick:RTU: see Rooftop_Unit\n      - brick:Filter: Device to remove gases from a mixture of gases or to remove solid material from a fluid\n        - brick:Mixed_Air_Filter: A filter that is applied to the mixture of recirculated and outside air\n      - brick:Humidifier: A device that adds moisture to air or other gases\n      - brick:Air_Plenum\n        - brick:Discharge_Air_Plenum\n        - brick:Return_Air_Plenum: A component of the HVAC the receives air from the room to recirculate or exhaust to or from the building\n      - brick:Condensing_Unit\n        - brick:Cooling_Only_Condensing_Unit\n          - brick:Cooling_Only_Air_Source_Condensing_Unit\n          - brick:Cooling_Only_Water_Source_Condensing_Unit\n          - brick:Cooling_Only_Ground_Source_Condensing_Unit\n      - brick:Damper\n        - brick:Relief_Damper: A damper that is a component of a Relief Air System, ensuring building doesn't become over-pressurised\n        - brick:Return_Damper: A damper that modulates the flow of return air\n        - brick:Outside_Damper: A damper that modulates the flow of outside air\n        - brick:Isolation_Damper: A damper that isolates a section of ductwork or other air handling system.\n        - brick:Mixed_Damper: A damper that modulates the flow of the mixed outside and return air streams\n        - brick:Exhaust_Damper: A damper that modulates the flow of exhaust air\n        - brick:Economizer_Damper: A damper that is part of an economizer that is used to module the flow of air\n      - brick:Fan\n        - brick:Fresh_Air_Fan\n        - brick:Cooling_Tower_Fan: A fan that pulls air through a cooling tower and across the louvers where the water falls to aid in heat exchange by the process of evaporation\n        - brick:Relief_Fan: A fan that is a component of a Relief Air System, ensuring building doesn't become over-pressurised\n        - brick:Standby_Fan: Fan that is activated as part of a lead/lag operation or when a primary fan raises an alarm\n        - brick:Return_Fan: Fan moving return air -- air that is circulated from the building back into the HVAC system\n        - brick:Transfer_Fan: A fan that transfers air from a space to another space.\n        - brick:Exhaust_Fan: Fan moving exhaust air -- air that must be removed from a space due to contaminants\n        - brick:Supply_Fan: Fan moving supply air -- air that is supplied from the HVAC system into the building\n        - brick:Booster_Fan: Fan activated to increase airflow beyond what is provided by the default configuration\n      - brick:Heat_Exchanger\n        - brick:Evaporative_Heat_Exchanger\n        - brick:Coil\n          - brick:Cooling_Coil: A cooling element made of pipe or tube that removes heat from equipment, machines or airflows. Typically filled with either refrigerant or cold water.\n      - brick:Terminal_Unit\n        - brick:Air_Diffuser: A device that is a component of the air distribution system that controls the delivery of conditioned and/or ventilating air into a room\n          - brick:Jet_Nozzle_Air_Diffuser: An air diffuser that is designed to produce high velocity discharge air stream to throw the air over a large distance or target the air stream to a localize area\n        - brick:Radiator: Heat exchangers designed to transfer thermal energy from one medium to another\n          - brick:Steam_Radiator: Radiator that uses steam\n            - brick:Steam_Baseboard_Radiator: Steam heating device located at or near the floor\n          - brick:Electric_Radiator: Electric heating device\n            - brick:Electric_Baseboard_Radiator: Electric heating device located at or near the floor\n          - brick:Hot_Water_Radiator: Radiator that uses hot water\n            - brick:Hot_Water_Baseboard_Radiator: Hydronic heating device located at or near the floor\n          - brick:Baseboard_Radiator: Steam, hydronic, or electric heating device located at or near the floor.\n        - brick:Chilled_Beam\n          - brick:Active_Chilled_Beam: A Chilled Beam with an integral primary air connection that induces air flow through the device.\n    - brick:ICT_Equipment\n      - brick:Sensor_Equipment\n        - brick:Thermostat_Equipment\n        - brick:Daylight_Sensor_Equipment\n        - brick:Occupancy_Sensor_Equipment\n        - brick:IAQ_Sensor_Equipment\n        - brick:People_Count_Sensor_Equipment\n    - brick:Lighting_Equipment\n      - brick:Interface: A device that provides an occupant control over a lighting system\n    - brick:Meter\n      - brick:Building_Meter: A meter that measures usage or consumption of some media for a whole building\n    - brick:Safety_Equipment\n      - brick:AED\n    - brick:Security_Equipment\n      - brick:Intercom_Equipment\n        - brick:Video_Intercom\n    - brick:Water_Heater\n      - brick:Collection_Basin_Water_Heater: Basin heaters prevent cold water basin freeze-up, e.g. in cooling towers, closed circuit fluid coolers, or evaporative condensers\n    - rec:ICTEquipment\n      - rec:SensorEquipment: Sensor equipment.; A piece of equipment for sensing some physical properties\n        - rec:DaylightSensorEquipment: Daylight sensor.\n        - rec:OccupancySensorEquipment: Occupancy sensor.; Detects occupancy of some space or area\n        - rec:PeopleCountSensorEquipment: People count sensor.\n  - brick:Point\n    - brick:Alarm\n      - brick:CO2_Alarm: An alarm that indicates the off-normal conditions associated with the presence of carbon dioxide.\n        - brick:High_CO2_Alarm: A device that indicates high concentration of carbon dioxide.\n      - brick:Temperature_Alarm: An alarm that indicates the off-normal conditions associated with temperature.\n        - brick:High_Temperature_Alarm: An alarm that indicates high temperature.\n      - brick:Air_Alarm\n        - brick:Air_Flow_Alarm: An alarm related to air flow.\n          - brick:Air_Flow_Loss_Alarm: An alarm that indicates loss in air flow.\n          - brick:High_Air_Flow_Alarm: An alarm that indicates that the air flow is higher than normal.\n        - brick:Discharge_Air_Smoke_Detection_Alarm\n        - brick:Supply_Air_Smoke_Detection_Alarm\n      - brick:Luminance_Alarm\n      - brick:Cycle_Alarm: An alarm that indicates off-normal conditions associated with HVAC cycles\n      - brick:Failure_Alarm\n        - brick:Sensor_Failure_Alarm\n      - brick:Humidity_Alarm\n        - brick:High_Humidity_Alarm: An alarm that indicates high concentration of water vapor in the air.\n      - brick:Smoke_Alarm\n        - brick:Smoke_Detection_Alarm\n    - brick:Command\n      - brick:Cooling_Command: Controls the amount of cooling to be delivered (typically as a proportion of total cooling output)\n      - brick:Occupancy_Command: Controls whether or not a device or controller is operating in \"Occupied\" mode\n      - brick:Dehumidify_Command: Triggers the dehumidification process, actively removing moisture from the air to achieve desired humidity levels\n      - brick:Disable_Command\n        - brick:Disable_Fixed_Temperature_Command: Disables the use of fixed temperature temperature\n      - brick:Enable_Command\n        - brick:Enable_Fixed_Temperature_Command: Enables the use of fixed temperature control\n        - brick:Cooling_Enable_Command: Command that enables cooling functionality in equipment but certain condition(s) must be met first before actively cooling. For the actively cooling control, see Cooling_Command.\n        - brick:Enable_Differential_Temperature_Command: Enables the use of differential temperature control\n        - brick:System_Enable_Command\n          - brick:Chilled_Water_System_Enable_Command: Enables operation of the chilled water system\n    - brick:Parameter\n      - brick:Alarm_Sensitivity_Parameter: A parameter indicates the sensitivity to activate an alarm.\n        - brick:CO2_Alarm_Sensitivity_Parameter: A parameter indicates the sensitivity to activate a CO2 alarm.\n        - brick:Temperature_Alarm_Sensitivity_Parameter: A parameter indicates the sensitivity to activate a temperature alarm.\n      - brick:Humidity_Parameter\n        - brick:Low_Humidity_Alarm_Parameter: A parameter determining the humidity level at which to trigger a low humidity alarm\n      - brick:Limit\n        - brick:Fresh_Air_Setpoint_Limit: A parameter that places a lower or upper bound on the range of permitted values of a Fresh_Air_Setpoint.\n        - brick:Min_Limit\n          - brick:Min_Temperature_Setpoint_Limit: A parameter that places a lower bound on the range of permitted values of a Temperature_Setpoint.\n      - brick:PID_Parameter\n        - brick:Proportional_Band_Parameter\n          - brick:Supply_Air_Temperature_Proportional_Band_Parameter\n            - brick:Cooling_Supply_Air_Temperature_Proportional_Band_Parameter\n      - brick:Temperature_Parameter\n        - brick:Low_Temperature_Alarm_Parameter: A parameter determining the temperature level at which to trigger a low temperature alarm\n    - brick:Sensor\n      - brick:Gas_Sensor: Measures gas concentration (other than CO2)\n      - brick:Temperature_Sensor: Measures temperature: the physical property of matter that quantitatively expresses the common notions of hot and cold\n        - brick:Water_Temperature_Sensor: Measures the temperature of water\n          - brick:Collection_Basin_Water_Temperature_Sensor: Measures the temperature of the water in the collection basin, e.g. within a Cooling_Tower\n          - brick:Domestic_Hot_Water_Temperature_Sensor\n          - brick:Supply_Water_Temperature_Sensor\n            - brick:Chilled_Water_Supply_Temperature_Sensor\n            - brick:Hot_Water_Supply_Temperature_Sensor\n              - brick:High_Temperature_Hot_Water_Supply_Temperature_Sensor\n              - brick:Medium_Temperature_Hot_Water_Supply_Temperature_Sensor\n              - brick:Domestic_Hot_Water_Supply_Temperature_Sensor\n          - brick:Heat_Exchanger_Supply_Water_Temperature_Sensor\n          - brick:Chilled_Water_Temperature_Sensor: Measures the temperature of chilled water\n            - brick:Chilled_Water_Return_Temperature_Sensor\n            - brick:Entering_Chilled_Water_Temperature_Sensor: Measures the temperature of chilled water that is enteringed to a cooling tower\n            - brick:Leaving_Chilled_Water_Temperature_Sensor: Measures the temperature of chilled water that is supplied from a chiller\n          - brick:Return_Water_Temperature_Sensor\n            - brick:Hot_Water_Return_Temperature_Sensor\n              - brick:Medium_Temperature_Hot_Water_Return_Temperature_Sensor\n              - brick:High_Temperature_Hot_Water_Return_Temperature_Sensor\n          - brick:Entering_Water_Temperature_Sensor: Measures the temperature of entering water\n        - brick:Natural_Gas_Temperature_Sensor: Measures the temperature of natural gas\n        - brick:Heat_Sink_Temperature_Sensor: Measure temperature of the heat sink on a device such as a VFD.\n        - brick:Air_Temperature_Sensor\n          - brick:Outside_Air_Temperature_Sensor: Measures the temperature of outside air\n            - brick:Outside_Air_Temperature_Enable_Differential_Sensor\n              - brick:Low_Outside_Air_Temperature_Enable_Differential_Sensor\n            - brick:Intake_Air_Temperature_Sensor: Measures air at the interface between the building and the outside\n        - brick:Radiant_Panel_Temperature_Sensor\n          - brick:Outside_Face_Surface_Temperature_Sensor: Measures the outside surface (relative to the space) of the radiant panel of a radiant heating and cooling HVAC system.\n      - brick:Heat_Sensor\n      - brick:Motion_Sensor: Detects the presence of motion in some area\n        - brick:PIR_Sensor: Detects the presense of motion in some area using the differential change in infrared intensity between two or more receptors\n      - brick:Solar_Radiance_Sensor\n      - brick:Refrigerant_Level_Sensor\n      - brick:Energy_Sensor: Measures energy consumption\n        - brick:Electric_Energy_Sensor\n        - brick:Energy_Usage_Sensor\n          - brick:Thermal_Energy_Usage_Sensor: A sensor that records the quantity of thermal energy consumed in a given period\n      - brick:Contact_Sensor: Senses or detects contact, such as for determining if a door is closed.\n      - brick:Adjust_Sensor: Measures user-provided adjustment of some value\n        - brick:Warm_Cool_Adjust_Sensor: User provided adjustment of zone temperature, typically in the range of +/- 5 degrees\n        - brick:Temperature_Adjust_Sensor: Measures user-provided adjustment of temperature\n      - brick:Conductivity_Sensor: Measures electrical conductance\n      - brick:Current_Sensor: Senses the amperes of electrical current passing through the sensor\n        - brick:Motor_Current_Sensor: Measures the current consumed by a motor\n      - brick:Angle_Sensor: Measues the planar angle of some phenomenon\n        - brick:Solar_Zenith_Angle_Sensor: Measures the zenith angle of the sun\n      - brick:Capacity_Sensor\n      - brick:Lighting_Correlated_Color_Temperature_Sensor: A sensor to measure correlated color temperature (CCT) which is the temperature of the Planckian radiator whose perceived color most closely resembles that of a given stimulus at the same brightness and under specified viewing conditions.\n      - brick:Usage_Sensor: Measures the amount of some substance that is consumed or used, over some period of time\n      - brick:Illuminance_Sensor: Measures the total luminous flux incident on a surface, per unit area\n        - brick:Outside_Illuminance_Sensor: Measures the total luminous flux incident on an outside, per unit area\n      - brick:Power_Sensor: Measures the amount of instantaneous power consumed\n        - brick:Thermal_Power_Sensor\n      - brick:Fire_Sensor: Measures the presence of fire\n      - brick:Air_Quality_Sensor: A sensor which provides a measure of air quality\n        - brick:CO2_Sensor: Measures properties of CO2 in air\n          - brick:CO2_Level_Sensor: Measures the concentration of CO2 in air\n            - brick:Zone_CO2_Level_Sensor: A physical or virtual sensor which represents the CO2 level of an HVAC Zone\n          - brick:Return_Air_CO2_Sensor: Measures the concentration of CO2 in return air\n          - brick:Outside_Air_CO2_Sensor: Measures the concentration of CO2 in outside air\n          - brick:CO2_Differential_Sensor: Measures the difference between CO2 levels of inside and outside air\n        - brick:CO_Sensor: Measures properties of CO\n          - brick:CO_Level_Sensor: Measures the concentration of CO\n          - brick:Return_Air_CO_Sensor: Measures the concentration of CO in return air\n          - brick:Outside_Air_CO_Sensor: Measures the concentration of CO in outside air\n          - brick:CO_Differential_Sensor\n        - brick:NO2_Level_Sensor: Measures the concentration of NO2 in air\n        - brick:Ammonia_Sensor\n        - brick:Methane_Level_Sensor: Measures the concentration of methane in air\n        - brick:Ozone_Level_Sensor: Measures the concentration of ozone in air\n        - brick:Particulate_Matter_Sensor\n          - brick:PM2.5_Sensor: Detects matter of size 2.5 microns\n            - brick:PM2.5_Level_Sensor: Detects level of particulates of size 2.5 microns\n      - brick:Position_Sensor: Measures the current position of a component in terms of a fraction of its full range of motion\n      - brick:Dewpoint_Sensor\n        - brick:Supply_Air_Dewpoint_Sensor\n      - brick:Duration_Sensor\n        - brick:Run_Time_Sensor: Measures the duration for which a device was in an active or \"on\" state\n        - brick:On_Timer_Sensor: Measures the duration for which a device was in an active or \"on\" state\n      - brick:Pressure_Sensor\n        - brick:Gauge_Pressure_Sensor: Pressure sensor which is zero-referenced against ambient air pressure\n    - brick:Setpoint\n      - brick:Temperature_Setpoint: Sets temperature\n        - brick:Cooling_Temperature_Setpoint: Sets temperature for cooling\n          - brick:Unoccupied_Cooling_Temperature_Setpoint\n          - brick:Occupied_Cooling_Temperature_Setpoint: Sets temperature for cooling when occupied\n          - brick:Supply_Air_Temperature_Cooling_Setpoint\n          - brick:Cooling_Supply_Air_Temperature_Deadband_Setpoint: Sets the size of a deadband of temperature of supply air for cooling\n          - brick:Occupied_Cooling_Temperature_Deadband_Setpoint: Sets the size of a deadband of temperature for cooling when occupied\n          - brick:Discharge_Air_Temperature_Cooling_Setpoint\n        - brick:Heating_Temperature_Setpoint: Sets temperature for heating\n        - brick:Water_Temperature_Setpoint: Sets temperature of water\n          - brick:Chilled_Water_Temperature_Setpoint: Sets the temperature of chilled water\n        - brick:Radiant_Panel_Temperature_Setpoint: Sets temperature of radiant panel.\n        - brick:Air_Temperature_Setpoint\n          - brick:Discharge_Air_Temperature_Setpoint\n            - brick:Supply_Air_Temperature_Deadband_Setpoint\n          - brick:Occupied_Air_Temperature_Setpoint\n            - brick:Occupied_Air_Temperature_Cooling_Setpoint\n          - brick:Supply_Air_Temperature_Setpoint\n          - brick:Unoccupied_Air_Temperature_Setpoint\n            - brick:Unoccupied_Air_Temperature_Cooling_Setpoint\n        - brick:Temperature_Deadband_Setpoint\n      - brick:CO2_Setpoint: Sets some property of CO2\n        - brick:Return_Air_CO2_Setpoint: Sets some property of CO2 in Return Air\n      - brick:Deadband_Setpoint\n      - brick:Demand_Setpoint\n        - brick:Cooling_Demand_Setpoint: Sets the rate required for cooling\n      - brick:Differential_Setpoint\n        - brick:Differential_Temperature_Setpoint: A type of Setpoints that is related to the difference between two temperature measurements\n      - brick:Flow_Setpoint\n        - brick:Air_Flow_Setpoint\n          - brick:Supply_Air_Flow_Setpoint\n            - brick:Cooling_Supply_Air_Flow_Setpoint: Sets supply air flow rate for cooling\n              - brick:Occupied_Cooling_Supply_Air_Flow_Setpoint: Sets supply air flow rate for cooling when occupied\n              - brick:Unoccupied_Cooling_Supply_Air_Flow_Setpoint\n              - brick:Occupied_Cooling_Discharge_Air_Flow_Setpoint: Sets discharge air flow for cooling when occupied\n            - brick:Cooling_Discharge_Air_Flow_Setpoint\n            - brick:Occupied_Supply_Air_Flow_Setpoint\n            - brick:Unoccupied_Supply_Air_Flow_Setpoint\n      - brick:Humidity_Setpoint\n        - brick:Unoccupied_Humidity_Setpoint: Target humidity level when the location is unoccupied.\n        - brick:Occupied_Humidity_Setpoint: Target humidity level when the location is occupied.\n    - brick:Status\n      - brick:Occupancy_Status: Indicates if a room or space is occupied\n        - brick:Temporary_Occupancy_Status: For systems that differentiate between scheduled occupied/unoccupied mode, this indicates if a space is temporarily occupied when it would otherwise be unoccupied\n      - brick:Availability_Status: Indicates if a piece of equipment, system, or functionality is available for operation\n      - brick:Mode_Status\n        - brick:Cooling_Mode_Status: Indicates whether a system, device or control loop is in a cooling mode\n          - brick:Occupied_Cooling_Mode_Status\n          - brick:Unoccupied_Cooling_Mode_Status: Indicates whether a system, device or control loop is in an unoccupied cooling mode\n        - brick:Occupied_Mode_Status\n        - brick:Unoccupied_Mode_Status\n      - brick:Off_Status\n        - brick:On_Off_Status\n          - brick:Remotely_On_Off_Status\n          - brick:Start_Stop_Status\n            - brick:Cooling_Start_Stop_Status\n      - brick:On_Status\n- brick:Entity\n- bsh:ValueShape\n  - bsh:TemperatureShape\n  - bsh:TemperatureQuantityShape\n  - bsh:TemperatureCoefficientPerDegreeCelsiusShape\n  - bsh:CoolingCapacityShape\n  - bsh:CO2_ConcentrationQuantityShape\n  - bsh:RadianceQuantityShape\n  - bsh:Operative_TemperatureQuantityShape\n  - bsh:Solar_RadianceQuantityShape\n  - bsh:Wet_Bulb_TemperatureQuantityShape\n  - bsh:Differential_CO2_ConcentrationQuantityShape\n  - bsh:CO_ConcentrationQuantityShape\n  - bsh:Radiant_TemperatureQuantityShape\n  - bsh:IrradianceQuantityShape\n  - bsh:Solar_IrradianceQuantityShape\n  - bsh:AzimuthShape\n  - bsh:Phasor_AngleQuantityShape\n  - bsh:PositionQuantityShape\n  - bsh:Radon_ConcentrationQuantityShape\n  - bsh:FrequencyQuantityShape\n  - bsh:Ozone_ConcentrationQuantityShape\n  - bsh:Thermal_EnergyQuantityShape\n  - bsh:PowerQuantityShape\n  - bsh:EfficiencyShape\n  - bsh:Wind_DirectionQuantityShape\n  - bsh:Apparent_EnergyQuantityShape\n  - bsh:Rotational_SpeedQuantityShape\n  - bsh:ThermalTransmittanceShape\n  - bsh:SpeedQuantityShape\n  - bsh:CoordinateShape\n  - bsh:TiltShape\n  - bsh:Current_AngleQuantityShape\n  - bsh:Phasor_MagnitudeQuantityShape\n  - bsh:TimeQuantityShape\n  - bsh:LastKnownValueShape\n    - bsh:LastKnownBooleanShape\n    - bsh:LastKnownDurationShape\n- owl:ObjectProperty\n  - brick:EntityProperty\n- rdfs:Resource\n  - rec:Asset\n    - rec:ArchitecturalAsset\n      - rec:BarrierAsset\n        - rec:Window\n    - rec:Furniture\n      - rec:Bed\n  - rec:BuildingElement\n    - rec:Balcony\n  - rec:Collection\n    - rec:Apartment\n  - rec:Event\n    - rec:PointEvent\n      - rec:ObservationEvent\n        - rec:TemperatureObservation\n        - rec:IlluminanceObservation\n        - rec:DistanceObservation\n        - rec:LuminousIntensityObservation\n        - rec:AngleObservation\n        - rec:EnergyObservation\n        - rec:LuminousFluxObservation\n  - rec:Information\n    - rec:ServiceObject\n      - rec:AlarmObject\n  - rec:Space\n    - rec:Architecture\n      - rec:Building\n        - rec:Hospital\n      - rec:Room\n        - rec:Bedroom\n        - rec:MultiPurposeRoom\n        - rec:CleaningRoom\n        - rec:EducationalRoom\n          - rec:SmallStudyRoom\n          - rec:GroupRoom\n        - rec:RecreationalRoom\n        - rec:RecordingRoom\n        - rec:HealthcareRoom\n          - rec:OperatingRoom\n          - rec:PharmacyRoom\n          - rec:OutpatientServicesRoom\n          - rec:AdmittingRoom\n          - rec:TherapyRoom\n        - rec:LivingRoom\n        - rec:LaundryRoom\n        - rec:RestingRoom\n        - rec:SecurityRoom\n        - rec:StaffRoom\n        - rec:LockerRoom\n        - rec:ConversationRoom\n        - rec:ExhibitionRoom\n        - rec:DressingRoom\n        - rec:ConferenceRoom: A space dedicated in which to hold a meetings\n        - rec:UtilitiesRoom\n          - rec:ElectricityRoom\n          - rec:CableRoom\n            - rec:TelecommunicationRoom\n        - rec:RetailRoom: A space set aside for retail in a larger establishment, e.g. a gift shop in a hospital\n          - rec:FittingRoom\n        - rec:Bathroom\n        - rec:PersonalHygiene\n          - rec:ShowerRoom\n          - rec:Sauna\n        - rec:Shelter\n          - rec:ShelterRoom\n        - rec:Cinema\n        - rec:ElevatorRoom\n        - rec:TreatmentRoom\n        - rec:CloakRoom\n        - rec:MeditationRoom\n        - rec:FoodHandlingRoom\n          - rec:BarRoom\n          - rec:DiningRoom\n          - rec:CookingRoom\n          - rec:CafeteriaRoom\n      - rec:Zone\n        - rec:OccupancyZone: Occupancy Zone is a spatial area where devices are monitoring or reporting on the concept of Occupancy (motion sensors, people counters, cameras, etc.)\n"
        }
    },
    "get_context_(2)": {
        "step_name": "get_context_(2)",
        "prompt": "",
        "thinking": "No Thinking",
        "response": "Now I need to map the relational property \"hasLocation\" to ontology properties:",
        "performance": {
            "time": {
                "latency": 3.99,
                "tpot": 0.0356,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 12243,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 1029,
                "output_tokens": 112,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "term_mapper_20250618_021347": {
        "tool_name": "term_mapper",
        "tool_input": {
            "ontology_path": "LLM_models/ontologies\\Brick.ttl",
            "terms": {
                "hasLocation": "property"
            }
        },
        "tool_result": {
            "mapped_terms": "Properties:\n- rec:isLocationOf\n- vcard:hasAddress\n- rec:hasPoint\n- brick:hasLocation: Subject is physically located in the location given by the object\n- brick:longitude\n- brick:latitude\n- brick:isLocationOf: Subject is the physical location encapsulating the object\n- rec:tripDirection\n- rec:locatedIn\n- rec:coordinates\n- brick:hasAmbientTemperature\n- rec:hasMember\n- rec:hasPart\n- rec:region\n- rec:address\n- rec:MACAddress\n- rec:area\n- rec:city\n- skos:broader\n- rec:coordinateSystem\n- rec:country\n- rec:georeference\n- brick:hasTag: The subject has the given tag\n- skos:narrower\n- ref:hasIfcProjectReference: A reference to the IFC Project that defines this entity\n- rec:postalCode\n- rec:IPAddress\n- rec:wifiSignalStrength\n- rec:targetPoint\n- brick:hasPart: The subject is composed in part of the entity given by the object\n- rec:status\n- rec:addressLine2\n- rec:leasor\n- brick:hasPoint: The subject has a source of telemetry identified by the object. In some systems the source of telemetry may be represented as a digital/analog input/output point\n- rec:addressLine1\n- rec:closedTime\n- rec:objectOfInterest\n- rec:rentableArea\n- rec:leaseOf\n- rec:initialCost\n- rec:timestamp\n- rec:createdTime\n- rec:originY\n- rec:maxOccupancy\n- rec:leasee\n"
        }
    },
    "get_context_(3)": {
        "step_name": "get_context_(3)",
        "prompt": "",
        "thinking": "No Thinking",
        "response": "Now I'll identify which of the mapped classes are appropriate for our JSON entities and check if they have numerical properties:",
        "performance": {
            "time": {
                "latency": 5.68,
                "tpot": 0.0325,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 12812,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 1029,
                "output_tokens": 175,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "classify_props_LLM_(0)": {
        "step_name": "classify_props_LLM_(0)",
        "prompt": "I need your help to classify properties from an ontology. I want to know if the ontology would allow to connect a numerical value with a class through a property\nGiven a list of properties, classify them into numerical and non-numerical categories.\nProperties are numerical if they (directly or inderictly through another class and property) connect an entity with a measurable quantity or quantity concept, such as temperature, count, or speed.\nProperties are non-numerical if they connect an entity with a another entity or description\nReturn a JSON object with two keys: 'numerical' and 'non_numerical'.\nThe input properties are:\n ['rdfs:comment', 'brick:deprecationMitigationMessage', 'owl:deprecated', 'brick:hasSubstance', 'owl:equivalentClass', 'brick:deprecatedInVersion', 'rdfs:subClassOf', 'brick:hasQuantity', 'brick:hasAssociatedTag', 'brick:isReplacedBy', 'rdfs:seeAlso', 'skos:definition', 'owl:disjointWith', 'rdfs:label']\n        <context>\n        # CoT Extraction\n        Bloom's Taxonomy:\n        - Remembering: {information} (Recall information)\n        - Understanding: {meaning} (Constructing meaning from information, e. g.: interpreting, exemplifying, classifying, summarizing, inferring, comparing, or explaining)\n        - Applying: {procedure} (using a procedure through executing, or implementing.)\n        - Analyzing: {analysis} (determine how concept parts relate to each other or how they interrelate, differentiating, organizing, and attributing, as well as being able to distinguish  between the components or parts.)\n        - Evaluating: {number of options considered} (Making judgments based on criteria and standards through checking and critiquing.)\n        - Creating: {newly created idea or element} (generating new ideas or elements.)\n\n        Knowledge Dimensions:\n        - Factual Knowledge: facts, terminology, or syntax needed to understand the domain.\n        - Conceptual Knowledge: classifications, principles, generalizations, theories, models, or structures pertinent to a particular disciplinary area\n        - Procedural Knowledge: How to do something, methods of inquiry, specific or finite skills, algorithms, techniques, and particular methodologies\n        - Metacognitive Knowledge: awareness of own cognition, strategic or reflective knowledge considering contextual and conditional knowledge and knowledge of self.\n        </context>\n\n        <instructions>\n        Do the task step by step.\n        Each step must:\n        - Perform exactly one logical action\n        - Have exactly one conceptual target\n        - be not devidable into smaller steps \n        - Produce exactly one concrete output\n        - Be completable in isolation\n        - Not require planning future steps\n\n        Output the thinking process as detailed as possible.\n        It is really important to output every little step of your reasoning, even if it seems obvious.\n\n        Process exactly ONE step at a time. \n        You cannot reference or work on any other step until the current one is complete. \n        After completing one step, explicitly state \"STEP COMPLETE\" before starting the next.\n        \n        You can only use information from:\n        - The original input\n        - Results from previously completed steps\n        - The current step you're working on\n        You cannot reference or anticipate future steps.\n        \n        For each step:\n        1. State what you're about to do\n            - context: the explicit context information that is needed to complete the step\n            - reason: the reasoning process that led to the step\n        2. Do it immediately \n        3. Show the result\n            - result: The actual concrete output produced (code, data, text) - not a description of what you will produce\n        4. Evaluate the step\n            - bloom: {objective} the Bloom's Taxonomy level and it's objective (max 7 words)\n            - dim: the Knowledge Dimension\n            - quantity: the number of context information items processed in this step. Items are either: entities, properties, relationships, paths, or lines of code.\n            - human_effort: own evaluation of the human effort required to complete this step (from 1 to 10, where 1 is very easy and 10 is very hard)\n        5. Move to next step\n\n        If you find yourself working on multiple entities simultaneously, STOP immediately and restart with only the first incomplete entity.\n        FINAL OUTPUT RULE: Only after ALL entities show 'ENTITY COMPLETE', combine all step results into the final deliverable.\n\n        Example format:\n        ...\n        STEP 1: {step name}\n            context: {context}\n            reason: {reasoning of the step}\n        EXECUTING: [actual code/work here]\n        RESULT:\n            result: {result of the step}\n        EVALUATION:\n            bloom: {bloom} {objective}\n            dim: {dim}\n            quantity: {quantity}\n            human_effort: {human_effort}\n\n        NEXT: STEP 2: {step name}\n        STEP COMPLETE\n        ...\n        </instructions>\n\n        <output>\n        Output the steps in <steps> tags. Put the response in output tags first, then the steps in <steps> tags after.\n        </output>\n        ",
        "thinking": "Let me approach this task step by step. I need to classify a list of properties from an ontology into numerical and non-numerical categories based on whether they connect an entity with a measurable quantity or with another entity/description.\n\nSTEP 1: Understand what makes a property numerical or non-numerical\ncontext: The definitions provided in the task description\nreason: I need to clearly understand the classification criteria before analyzing the properties\n\nNumerical properties are defined as those that:\n- Connect an entity with a measurable quantity or quantity concept (temperature, count, speed, etc.)\n- This connection can be direct or indirect (through another class and property)\n\nNon-numerical properties are defined as those that:\n- Connect an entity with another entity or description (not a measurable quantity)\n\nRESULT:\nresult: \n- Numerical properties: Connect to measurable quantities (directly or indirectly)\n- Non-numerical properties: Connect to other entities or descriptions (not quantities)\n\nEVALUATION:\nbloom: Understanding classification criteria\ndim: Conceptual Knowledge\nquantity: 2 (numerical properties concept, non-numerical properties concept)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 2: List all properties to be classified\ncontext: The input properties provided in the task\nreason: I need a clear list of all properties I need to classify\n\nEXECUTING:\nThe properties to classify are:\n1. rdfs:comment\n2. brick:deprecationMitigationMessage\n3. owl:deprecated\n4. brick:hasSubstance\n5. owl:equivalentClass\n6. brick:deprecatedInVersion\n7. rdfs:subClassOf\n8. brick:hasQuantity\n9. brick:hasAssociatedTag\n10. brick:isReplacedBy\n11. rdfs:seeAlso\n12. skos:definition\n13. owl:disjointWith\n14. rdfs:label\n\nRESULT:\nresult: Complete list of 14 properties to classify\n\nEVALUATION:\nbloom: Remembering listing properties\ndim: Factual Knowledge\nquantity: 14 (properties)\nhuman_effort: 2\n\nSTEP COMPLETE\n\nSTEP 3: Analyze rdfs:comment\ncontext: The property rdfs:comment and knowledge of RDF Schema\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe rdfs:comment property in RDF Schema is used to provide human-readable descriptions or comments about resources. It connects an entity to a text description, not to a measurable quantity.\n\nRESULT:\nresult: rdfs:comment is a non-numerical property as it connects an entity to a text description.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 4: Analyze brick:deprecationMitigationMessage\ncontext: The property brick:deprecationMitigationMessage\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nBased on the name, brick:deprecationMitigationMessage appears to be a property that provides a message or information about how to mitigate the deprecation of an entity. This connects an entity to a text message, not to a measurable quantity.\n\nRESULT:\nresult: brick:deprecationMitigationMessage is a non-numerical property as it connects to a textual message.\n\nEVALUATION:\nbloom: Analyzing property semantics\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 4\n\nSTEP COMPLETE\n\nSTEP 5: Analyze owl:deprecated\ncontext: The property owl:deprecated and knowledge of OWL\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe owl:deprecated property in OWL is used to indicate that a term is deprecated. It typically has a boolean value (true/false) indicating whether something is deprecated or not. While boolean values are represented numerically (0/1), they don't represent a measurable quantity in the sense described in the task (like temperature, count, or speed).\n\nRESULT:\nresult: owl:deprecated is a non-numerical property as it represents a boolean state, not a measurable quantity.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 4\n\nSTEP COMPLETE\n\nSTEP 6: Analyze brick:hasSubstance\ncontext: The property brick:hasSubstance\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe brick:hasSubstance property appears to connect an entity to a substance (a material or matter). This is connecting one entity (something) to another entity (a substance), not to a measurable quantity.\n\nRESULT:\nresult: brick:hasSubstance is a non-numerical property as it connects an entity to a substance.\n\nEVALUATION:\nbloom: Analyzing property semantics\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 7: Analyze owl:equivalentClass\ncontext: The property owl:equivalentClass and knowledge of OWL\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe owl:equivalentClass property in OWL is used to state that two classes contain exactly the same instances. It connects one class to another class, not to a measurable quantity.\n\nRESULT:\nresult: owl:equivalentClass is a non-numerical property as it connects a class to another class.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 8: Analyze brick:deprecatedInVersion\ncontext: The property brick:deprecatedInVersion\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe brick:deprecatedInVersion property seems to indicate the version in which an entity was deprecated. While versions often contain numbers (e.g., \"2.0\"), they are identifiers rather than measurable quantities. The property connects an entity to a version identifier, not to a quantity that can be measured.\n\nRESULT:\nresult: brick:deprecatedInVersion is a non-numerical property as it connects to a version identifier, not a measurable quantity.\n\nEVALUATION:\nbloom: Analyzing property semantics\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 5\n\nSTEP COMPLETE\n\nSTEP 9: Analyze rdfs:subClassOf\ncontext: The property rdfs:subClassOf and knowledge of RDF Schema\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe rdfs:subClassOf property in RDF Schema is used to establish a hierarchical relationship between classes, indicating that one class is a subclass of another. It connects one class to another class, not to a measurable quantity.\n\nRESULT:\nresult: rdfs:subClassOf is a non-numerical property as it connects a class to another class.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 10: Analyze brick:hasQuantity\ncontext: The property brick:hasQuantity\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe brick:hasQuantity property, based on its name, appears to connect an entity to a quantity. The term \"quantity\" strongly suggests a measurable value or concept, which aligns with the definition of a numerical property provided in the task.\n\nRESULT:\nresult: brick:hasQuantity is a numerical property as it connects an entity to a quantity concept.\n\nEVALUATION:\nbloom: Analyzing property semantics\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 4\n\nSTEP COMPLETE\n\nSTEP 11: Analyze brick:hasAssociatedTag\ncontext: The property brick:hasAssociatedTag\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe brick:hasAssociatedTag property appears to connect an entity to a tag or label. This is connecting one entity to another entity (a tag) or to a description, not to a measurable quantity.\n\nRESULT:\nresult: brick:hasAssociatedTag is a non-numerical property as it connects an entity to a tag.\n\nEVALUATION:\nbloom: Analyzing property semantics\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 12: Analyze brick:isReplacedBy\ncontext: The property brick:isReplacedBy\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe brick:isReplacedBy property appears to indicate that one entity is replaced by another entity. This connects one entity to another entity, not to a measurable quantity.\n\nRESULT:\nresult: brick:isReplacedBy is a non-numerical property as it connects an entity to another entity.\n\nEVALUATION:\nbloom: Analyzing property semantics\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 13: Analyze rdfs:seeAlso\ncontext: The property rdfs:seeAlso and knowledge of RDF Schema\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe rdfs:seeAlso property in RDF Schema is used to provide a reference to another resource that might provide additional information about the subject resource. It connects one entity to another entity, not to a measurable quantity.\n\nRESULT:\nresult: rdfs:seeAlso is a non-numerical property as it connects an entity to another resource.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 14: Analyze skos:definition\ncontext: The property skos:definition and knowledge of SKOS\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe skos:definition property in SKOS (Simple Knowledge Organization System) is used to provide a complete explanation of the intended meaning of a concept. It connects a concept to a text definition, not to a measurable quantity.\n\nRESULT:\nresult: skos:definition is a non-numerical property as it connects a concept to a text definition.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 15: Analyze owl:disjointWith\ncontext: The property owl:disjointWith and knowledge of OWL\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe owl:disjointWith property in OWL is used to state that two classes have no instances in common. It connects one class to another class, not to a measurable quantity.\n\nRESULT:\nresult: owl:disjointWith is a non-numerical property as it connects a class to another class.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 16: Analyze rdfs:label\ncontext: The property rdfs:label and knowledge of RDF Schema\nreason: I need to determine if this property connects to a numerical value or not\n\nEXECUTING:\nThe rdfs:label property in RDF Schema is used to provide a human-readable version of a resource's name. It connects an entity to a text label, not to a measurable quantity.\n\nRESULT:\nresult: rdfs:label is a non-numerical property as it connects an entity to a text label.\n\nEVALUATION:\nbloom: Analyzing property function\ndim: Conceptual Knowledge\nquantity: 1 (property)\nhuman_effort: 3\n\nSTEP COMPLETE\n\nSTEP 17: Compile the classification results\ncontext: All the individual property classifications from previous steps\nreason: I need to organize the results into the required JSON format\n\nEXECUTING:\nBased on the analysis of all properties, I can now compile them into numerical and non-numerical categories:\n\nNumerical properties:\n- brick:hasQuantity\n\nNon-numerical properties:\n- rdfs:comment\n- brick:deprecationMitigationMessage\n- owl:deprecated\n- brick:hasSubstance\n- owl:equivalentClass\n- brick:deprecatedInVersion\n- rdfs:subClassOf\n- brick:hasAssociatedTag\n- brick:isReplacedBy\n- rdfs:seeAlso\n- skos:definition\n- owl:disjointWith\n- rdfs:label\n\nRESULT:\nresult: \n{\n  \"numerical\": [\"brick:hasQuantity\"],\n  \"non_numerical\": [\n    \"rdfs:comment\",\n    \"brick:deprecationMitigationMessage\",\n    \"owl:deprecated\",\n    \"brick:hasSubstance\",\n    \"owl:equivalentClass\",\n    \"brick:deprecatedInVersion\",\n    \"rdfs:subClassOf\",\n    \"brick:hasAssociatedTag\",\n    \"brick:isReplacedBy\",\n    \"rdfs:seeAlso\",\n    \"skos:definition\",\n    \"owl:disjointWith\",\n    \"rdfs:label\"\n  ]\n}\n\nEVALUATION:\nbloom: Creating classification output\ndim: Conceptual Knowledge\nquantity: 14 (properties)\nhuman_effort: 5\n\nSTEP COMPLETE\n\nSTEP 18: Format the final JSON output\ncontext: The classification results from Step 17\nreason: I need to present the final answer in the required JSON format\n\nEXECUTING:\nI'll format the final JSON object with the two required keys: 'numerical' and 'non_numerical'\n\nRESULT:\nresult: \n{\n  \"numerical\": [\"brick:hasQuantity\"],\n  \"non_numerical\": [\n    \"rdfs:comment\",\n    \"brick:deprecationMitigationMessage\",\n    \"owl:deprecated\",\n    \"brick:hasSubstance\",\n    \"owl:equivalentClass\",\n    \"brick:deprecatedInVersion\",\n    \"rdfs:subClassOf\",\n    \"brick:hasAssociatedTag\",\n    \"brick:isReplacedBy\",\n    \"rdfs:seeAlso\",\n    \"skos:definition\",\n    \"owl:disjointWith\",\n    \"rdfs:label\"\n  ]\n}\n\nEVALUATION:\nbloom: Creating formatted output\ndim: Procedural Knowledge\nquantity: 14 (properties)\nhuman_effort: 2\n\nSTEP COMPLETE",
        "response": "<output>\n{\n  \"numerical\": [\"brick:hasQuantity\"],\n  \"non_numerical\": [\n    \"rdfs:comment\",\n    \"brick:deprecationMitigationMessage\",\n    \"owl:deprecated\",\n    \"brick:hasSubstance\",\n    \"owl:equivalentClass\",\n    \"brick:deprecatedInVersion\",\n    \"rdfs:subClassOf\",\n    \"brick:hasAssociatedTag\",\n    \"brick:isReplacedBy\",\n    \"rdfs:seeAlso\",\n    \"skos:definition\",\n    \"owl:disjointWith\",\n    \"rdfs:label\"\n  ]\n}\n</output>\n\n",
        "performance": {
            "time": {
                "latency": 44.67,
                "tpot": 0.0124,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 1277,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 0,
                "output_tokens": 3610,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "get_non_numeric_classes": {
        "tool_name": "get_non_numeric_classes",
        "tool_input": {
            "ontology_path": "LLM_models/ontologies\\Brick.ttl",
            "target_classes": [
                "brick:Room",
                "brick:CO2_Sensor",
                "brick:Temperature_Sensor",
                "brick:PIR_Sensor",
                "brick:Cooling_Coil",
                "brick:Radiator",
                "brick:Ventilation_Air_System"
            ]
        },
        "tool_result": {
            "error": true,
            "message": "⚠️  Error executing tool 'get_non_numeric_classes': 'str' object has no attribute 'get'",
            "details": "'str' object has no attribute 'get'"
        }
    },
    "get_context_(4)": {
        "step_name": "get_context_(4)",
        "prompt": "",
        "thinking": "No Thinking",
        "response": "Let me try again with the correct format:",
        "performance": {
            "time": {
                "latency": 3.92,
                "tpot": 0.0243,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 13054,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 1029,
                "output_tokens": 161,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "classify_props_LLM_(0)_20250618_021528": {
        "step_name": "classify_props_LLM_(0)",
        "prompt": "I need your help to classify properties from an ontology. I want to know if the ontology would allow to connect a numerical value with a class through a property\nGiven a list of properties, classify them into numerical and non-numerical categories.\nProperties are numerical if they (directly or inderictly through another class and property) connect an entity with a measurable quantity or quantity concept, such as temperature, count, or speed.\nProperties are non-numerical if they connect an entity with a another entity or description\nReturn a JSON object with two keys: 'numerical' and 'non_numerical'.\nThe input properties are:\n ['rdfs:comment', 'brick:deprecationMitigationMessage', 'owl:deprecated', 'brick:hasSubstance', 'owl:equivalentClass', 'brick:deprecatedInVersion', 'rdfs:subClassOf', 'brick:hasQuantity', 'brick:hasAssociatedTag', 'brick:isReplacedBy', 'rdfs:seeAlso', 'skos:definition', 'owl:disjointWith', 'rdfs:label']\n        <context>\n        # CoT Extraction\n        Bloom's Taxonomy:\n        - Remembering: {information} (Recall information)\n        - Understanding: {meaning} (Constructing meaning from information, e. g.: interpreting, exemplifying, classifying, summarizing, inferring, comparing, or explaining)\n        - Applying: {procedure} (using a procedure through executing, or implementing.)\n        - Analyzing: {analysis} (determine how concept parts relate to each other or how they interrelate, differentiating, organizing, and attributing, as well as being able to distinguish  between the components or parts.)\n        - Evaluating: {number of options considered} (Making judgments based on criteria and standards through checking and critiquing.)\n        - Creating: {newly created idea or element} (generating new ideas or elements.)\n\n        Knowledge Dimensions:\n        - Factual Knowledge: facts, terminology, or syntax needed to understand the domain.\n        - Conceptual Knowledge: classifications, principles, generalizations, theories, models, or structures pertinent to a particular disciplinary area\n        - Procedural Knowledge: How to do something, methods of inquiry, specific or finite skills, algorithms, techniques, and particular methodologies\n        - Metacognitive Knowledge: awareness of own cognition, strategic or reflective knowledge considering contextual and conditional knowledge and knowledge of self.\n        </context>\n\n        <instructions>\n        Do the task step by step.\n        Each step must:\n        - Perform exactly one logical action\n        - Have exactly one conceptual target\n        - be not devidable into smaller steps \n        - Produce exactly one concrete output\n        - Be completable in isolation\n        - Not require planning future steps\n\n        Output the thinking process as detailed as possible.\n        It is really important to output every little step of your reasoning, even if it seems obvious.\n\n        Process exactly ONE step at a time. \n        You cannot reference or work on any other step until the current one is complete. \n        After completing one step, explicitly state \"STEP COMPLETE\" before starting the next.\n        \n        You can only use information from:\n        - The original input\n        - Results from previously completed steps\n        - The current step you're working on\n        You cannot reference or anticipate future steps.\n        \n        For each step:\n        1. State what you're about to do\n            - context: the explicit context information that is needed to complete the step\n            - reason: the reasoning process that led to the step\n        2. Do it immediately \n        3. Show the result\n            - result: The actual concrete output produced (code, data, text) - not a description of what you will produce\n        4. Evaluate the step\n            - bloom: {objective} the Bloom's Taxonomy level and it's objective (max 7 words)\n            - dim: the Knowledge Dimension\n            - quantity: the number of context information items processed in this step. Items are either: entities, properties, relationships, paths, or lines of code.\n            - human_effort: own evaluation of the human effort required to complete this step (from 1 to 10, where 1 is very easy and 10 is very hard)\n        5. Move to next step\n\n        If you find yourself working on multiple entities simultaneously, STOP immediately and restart with only the first incomplete entity.\n        FINAL OUTPUT RULE: Only after ALL entities show 'ENTITY COMPLETE', combine all step results into the final deliverable.\n\n        Example format:\n        ...\n        STEP 1: {step name}\n            context: {context}\n            reason: {reasoning of the step}\n        EXECUTING: [actual code/work here]\n        RESULT:\n            result: {result of the step}\n        EVALUATION:\n            bloom: {bloom} {objective}\n            dim: {dim}\n            quantity: {quantity}\n            human_effort: {human_effort}\n\n        NEXT: STEP 2: {step name}\n        STEP COMPLETE\n        ...\n        </instructions>\n\n        <output>\n        Output the steps in <steps> tags. Put the response in output tags first, then the steps in <steps> tags after.\n        </output>\n        ",
        "thinking": "Alright, I need to classify a list of properties from an ontology into numerical and non-numerical categories. Let me break this down into steps to ensure I approach this systematically.\n\nSTEP 1: Understand the classification criteria\n    context: The task is to classify ontology properties into numerical and non-numerical categories.\n    reason: Before I can classify the properties, I need to clearly understand what makes a property \"numerical\" or \"non-numerical\" according to the task description.\n\nEXECUTING: Extracting the criteria from the task description\nFrom the task description, I understand that:\n- Numerical properties are those that directly or indirectly (through another class and property) connect an entity with a measurable quantity or quantity concept, such as temperature, count, or speed.\n- Non-numerical properties are those that connect an entity with another entity or description.\n\nRESULT:\n    result: \n    Numerical properties: Connect entities to measurable quantities (directly or indirectly)\n    Non-numerical properties: Connect entities to other entities or descriptions\n\nEVALUATION:\n    bloom: Understanding interpreting classification criteria\n    dim: Conceptual Knowledge\n    quantity: 2 (numerical property definition, non-numerical property definition)\n    human_effort: 3\n\nNEXT: STEP 2: Analyze each property in the list\nSTEP COMPLETE\n\nSTEP 2: Analyze each property in the list\n    context: List of properties to classify: ['rdfs:comment', 'brick:deprecationMitigationMessage', 'owl:deprecated', 'brick:hasSubstance', 'owl:equivalentClass', 'brick:deprecatedInVersion', 'rdfs:subClassOf', 'brick:hasQuantity', 'brick:hasAssociatedTag', 'brick:isReplacedBy', 'rdfs:seeAlso', 'skos:definition', 'owl:disjointWith', 'rdfs:label']\n    reason: I need to examine each property one by one to determine if it connects to a numerical value or not.\n\nEXECUTING: I'll analyze each property based on its name and the typical usage in ontologies.\n\n1. rdfs:comment - This is a standard RDF Schema property used to provide human-readable descriptions of resources. It typically connects an entity to a string literal description.\n\n2. brick:deprecationMitigationMessage - Based on the name, this seems to provide a message about how to mitigate the deprecation of a resource. It would connect to a text description.\n\n3. owl:deprecated - This is a boolean property indicating whether a resource is deprecated. While it could be represented as 0/1, it's conceptually a status indicator rather than a measurable quantity.\n\n4. brick:hasSubstance - This appears to connect an entity to the substance it contains or is made of, which would be another entity or concept, not a numerical value.\n\n5. owl:equivalentClass - This is a standard OWL property that establishes an equivalence relationship between two classes. It connects classes to classes, not to numerical values.\n\n6. brick:deprecatedInVersion - This likely refers to the version number in which a resource was deprecated. While versions often have numerical components, the version itself is conceptually an identifier rather than a measurable quantity.\n\n7. rdfs:subClassOf - This is a standard RDF Schema property establishing a subclass relationship. It connects a class to its superclass, not to a numerical value.\n\n8. brick:hasQuantity - This explicitly refers to a quantity, which strongly suggests it connects an entity to a measurable value or quantity concept.\n\n9. brick:hasAssociatedTag - This appears to connect an entity with a tag or label, which would be another entity or a string, not a numerical value.\n\n10. brick:isReplacedBy - This likely indicates that one resource is replaced by another resource, establishing a relationship between entities rather than connecting to a numerical value.\n\n11. rdfs:seeAlso - This is a standard RDF Schema property that provides a reference to another resource for additional information. It connects resources to resources, not to numerical values.\n\n12. skos:definition - This is a SKOS property for providing a complete explanation of the intended meaning of a concept. It typically connects to a text description.\n\n13. owl:disjointWith - This is a standard OWL property that establishes that two classes have no members in common. It connects classes to classes, not to numerical values.\n\n14. rdfs:label - This is a standard RDF Schema property for providing a human-readable name for a resource. It typically connects to a string literal.\n\nRESULT:\n    result: \n    Numerical properties:\n    - brick:hasQuantity\n\n    Non-numerical properties:\n    - rdfs:comment\n    - brick:deprecationMitigationMessage\n    - owl:deprecated\n    - brick:hasSubstance\n    - owl:equivalentClass\n    - brick:deprecatedInVersion\n    - rdfs:subClassOf\n    - brick:hasAssociatedTag\n    - brick:isReplacedBy\n    - rdfs:seeAlso\n    - skos:definition\n    - owl:disjointWith\n    - rdfs:label\n\nEVALUATION:\n    bloom: Analyzing categorizing properties by function\n    dim: Conceptual Knowledge\n    quantity: 14 (one analysis per property)\n    human_effort: 7\n\nNEXT: STEP 3: Format the result as a JSON object\nSTEP COMPLETE\n\nSTEP 3: Format the result as a JSON object\n    context: The classification results from Step 2\n    reason: The task requires the output to be a JSON object with 'numerical' and 'non_numerical' keys.\n\nEXECUTING: Creating a JSON object with the classified properties\n\n```json\n{\n  \"numerical\": [\n    \"brick:hasQuantity\"\n  ],\n  \"non_numerical\": [\n    \"rdfs:comment\",\n    \"brick:deprecationMitigationMessage\",\n    \"owl:deprecated\",\n    \"brick:hasSubstance\",\n    \"owl:equivalentClass\",\n    \"brick:deprecatedInVersion\",\n    \"rdfs:subClassOf\",\n    \"brick:hasAssociatedTag\",\n    \"brick:isReplacedBy\",\n    \"rdfs:seeAlso\",\n    \"skos:definition\",\n    \"owl:disjointWith\",\n    \"rdfs:label\"\n  ]\n}\n```\n\nRESULT:\n    result: \n    {\n      \"numerical\": [\n        \"brick:hasQuantity\"\n      ],\n      \"non_numerical\": [\n        \"rdfs:comment\",\n        \"brick:deprecationMitigationMessage\",\n        \"owl:deprecated\",\n        \"brick:hasSubstance\",\n        \"owl:equivalentClass\",\n        \"brick:deprecatedInVersion\",\n        \"rdfs:subClassOf\",\n        \"brick:hasAssociatedTag\",\n        \"brick:isReplacedBy\",\n        \"rdfs:seeAlso\",\n        \"skos:definition\",\n        \"owl:disjointWith\",\n        \"rdfs:label\"\n      ]\n    }\n\nEVALUATION:\n    bloom: Applying formatting data as JSON\n    dim: Procedural Knowledge\n    quantity: 14 (all properties being formatted)\n    human_effort: 2\n\nNEXT: STEP 4: Review the classification for accuracy\nSTEP COMPLETE\n\nSTEP 4: Review the classification for accuracy\n    context: The classification done in Step 2 and formatted in Step 3\n    reason: I should double-check my classification to ensure it correctly follows the criteria.\n\nEXECUTING: Re-examining each property with a focus on whether it could indirectly connect to numerical values.\n\nLooking at the criteria again:\n- Numerical properties connect entities to measurable quantities (directly or indirectly)\n- Non-numerical properties connect entities to other entities or descriptions\n\nLet me reconsider each property:\n\n1. rdfs:comment - Connects to a text description. Not numerical.\n2. brick:deprecationMitigationMessage - Connects to a text message. Not numerical.\n3. owl:deprecated - Boolean status indicator. Not a measurable quantity in the context of the ontology.\n4. brick:hasSubstance - Connects to another entity (a substance). Not numerical.\n5. owl:equivalentClass - Connects classes to classes. Not numerical.\n6. brick:deprecatedInVersion - Connects to a version identifier. While versions may contain numbers, they are identifiers rather than measurable quantities.\n7. rdfs:subClassOf - Connects classes in a hierarchy. Not numerical.\n8. brick:hasQuantity - Explicitly connects to a quantity concept. Numerical.\n9. brick:hasAssociatedTag - Connects to a tag or label. Not numerical.\n10. brick:isReplacedBy - Connects resources to resources. Not numerical.\n11. rdfs:seeAlso - References another resource. Not numerical.\n12. skos:definition - Provides a text definition. Not numerical.\n13. owl:disjointWith - Establishes a relationship between classes. Not numerical.\n14. rdfs:label - Provides a text label. Not numerical.\n\nI don't see any properties that I misclassified. The classification appears to be accurate.\n\nRESULT:\n    result: The classification is correct. Only \"brick:hasQuantity\" is a numerical property as it directly connects to quantity concepts. All other properties connect to entities, classes, or text descriptions, not to measurable quantities.\n\nEVALUATION:\n    bloom: Evaluating verifying classification accuracy\n    dim: Metacognitive Knowledge\n    quantity: 14 (re-examining all properties)\n    human_effort: 5\n\nNEXT: STEP 5: Finalize the JSON output\nSTEP COMPLETE\n\nSTEP 5: Finalize the JSON output\n    context: The verified classification from Step 4\n    reason: I need to ensure the final output meets the task requirements.\n\nEXECUTING: Confirming the JSON structure and content\n\nThe task requires a JSON object with two keys: 'numerical' and 'non_numerical'.\nThe JSON object I created in Step 3 has these two keys.\nThe 'numerical' array contains only \"brick:hasQuantity\".\nThe 'non_numerical' array contains all other properties.\nThis matches our verified classification from Step 4.\n\nRESULT:\n    result: \n    {\n      \"numerical\": [\n        \"brick:hasQuantity\"\n      ],\n      \"non_numerical\": [\n        \"rdfs:comment\",\n        \"brick:deprecationMitigationMessage\",\n        \"owl:deprecated\",\n        \"brick:hasSubstance\",\n        \"owl:equivalentClass\",\n        \"brick:deprecatedInVersion\",\n        \"rdfs:subClassOf\",\n        \"brick:hasAssociatedTag\",\n        \"brick:isReplacedBy\",\n        \"rdfs:seeAlso\",\n        \"skos:definition\",\n        \"owl:disjointWith\",\n        \"rdfs:label\"\n      ]\n    }\n\nEVALUATION:\n    bloom: Evaluating confirming output meets requirements\n    dim: Metacognitive Knowledge\n    quantity: 2 (the numerical and non_numerical arrays)\n    human_effort: 2\n\nSTEP COMPLETE\n\nNow I'll provide the final response combining all my results.",
        "response": "<output>\n{\n  \"numerical\": [\n    \"brick:hasQuantity\"\n  ],\n  \"non_numerical\": [\n    \"rdfs:comment\",\n    \"brick:deprecationMitigationMessage\",\n    \"owl:deprecated\",\n    \"brick:hasSubstance\",\n    \"owl:equivalentClass\",\n    \"brick:deprecatedInVersion\",\n    \"rdfs:subClassOf\",\n    \"brick:hasAssociatedTag\",\n    \"brick:isReplacedBy\",\n    \"rdfs:seeAlso\",\n    \"skos:definition\",\n    \"owl:disjointWith\",\n    \"rdfs:label\"\n  ]\n}\n</output>\n\n",
        "performance": {
            "time": {
                "latency": 40.43,
                "tpot": 0.0144,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 1277,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 0,
                "output_tokens": 2798,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    },
    "get_non_numeric_classes_20250618_021528": {
        "tool_name": "get_non_numeric_classes",
        "tool_input": {
            "ontology_path": "LLM_models/ontologies\\Brick.ttl",
            "target_classes": [
                "brick:Room",
                "brick:CO2_Sensor",
                "brick:Temperature_Sensor",
                "brick:PIR_Sensor",
                "brick:Cooling_Coil",
                "brick:Radiator",
                "brick:Ventilation_Air_System"
            ]
        },
        "tool_result": {
            "error": true,
            "message": "⚠️  Error executing tool 'get_non_numeric_classes': 'str' object has no attribute 'get'",
            "details": "'str' object has no attribute 'get'"
        }
    },
    "get_context_(5)": {
        "step_name": "get_context_(5)",
        "prompt": "",
        "thinking": "No Thinking",
        "response": "Based on the available information and tools, I'll compile the results and provide a comprehensive JSON output with mappings between JSON entities and Brick ontology classes and properties.\n\n<output>\n{\n  \"api_endpoint\": \"https://fiware.eonerc.rwth-aachen.de/v2/entities/{entityId}/attrs/{attrName}/value\",\n  \"properties\": {\n    \"numerical_properties\": [\n      \"temperatureAmb\",\n      \"temperature\",\n      \"co2\",\n      \"pir\",\n      \"airFlowSetpoint\",\n      \"temperatureSetpoint\",\n      \"fanSpeed\"\n    ],\n    \"relational_properties\": [\n      \"hasLocation\"\n    ]\n  },\n  \"entity_to_ontology_mapping\": {\n    \"Hotel\": \"brick:Building\",\n    \"HotelRoom\": \"brick:Room\",\n    \"AmbientTemperatureSensor\": \"brick:Temperature_Sensor\",\n    \"TemperatureSensor\": \"brick:Temperature_Sensor\",\n    \"CO2Sensor\": \"brick:CO2_Sensor\",\n    \"PresenceSensor\": \"brick:PIR_Sensor\",\n    \"FreshAirVentilation\": \"brick:Ventilation_Air_System\",\n    \"RadiatorThermostat\": \"brick:Radiator\",\n    \"CoolingCoil\": \"brick:Cooling_Coil\"\n  },\n  \"property_to_ontology_mapping\": {\n    \"hasLocation\": \"brick:hasLocation\"\n  },\n  \"extra_nodes\": {\n    \"temperature\": {\n      \"entity_name\": \"Temperature\",\n      \"ontology_class\": \"brick:Temperature_Sensor\"\n    },\n    \"temperatureAmb\": {\n      \"entity_name\": \"AmbientTemperature\",\n      \"ontology_class\": \"brick:Temperature_Sensor\"\n    },\n    \"co2\": {\n      \"entity_name\": \"CO2Level\",\n      \"ontology_class\": \"brick:CO2_Level_Sensor\"\n    },\n    \"pir\": {\n      \"entity_name\": \"PresenceDetection\",\n      \"ontology_class\": \"brick:Occupancy_Status\"\n    },\n    \"airFlowSetpoint\": {\n      \"entity_name\": \"AirFlowControl\",\n      \"ontology_class\": \"brick:Air_Flow_Setpoint\"\n    },\n    \"temperatureSetpoint\": {\n      \"entity_name\": \"TemperatureControl\",\n      \"ontology_class\": \"brick:Temperature_Setpoint\"\n    },\n    \"fanSpeed\": {\n      \"entity_name\": \"FanSpeedControl\",\n      \"ontology_class\": \"brick:Fan\"\n    }\n  }\n}\n</output>",
        "performance": {
            "time": {
                "latency": 10.96,
                "tpot": 0.0163,
                "ttft": null
            },
            "tokens": {
                "input_tokens": 13282,
                "cache_creation_input_tokens": 0,
                "cache_read_input_tokens": 1029,
                "output_tokens": 674,
                "service_tier": "standard"
            }
        },
        "sub_steps": null
    }
}


"""
format_string(string)


evaluations = extract_evaluations(string)
